{"version":3,"sources":["../../../../../../Desktop/worflow-app/node_modules/next/src/build/webpack/loaders/next-flight-loader/action-validate.ts","../../../../../../Desktop/worflow-app/actions/settings-actions.ts","../../../../../../Desktop/worflow-app/.next-internal/server/app/%28authenticated%29/settings/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["// This function ensures that all the exported values are valid server actions,\n// during the runtime. By definition all actions are required to be async\n// functions, but here we can only check that they are functions.\nexport function ensureServerEntryExports(actions: any[]) {\n  for (let i = 0; i < actions.length; i++) {\n    const action = actions[i]\n    if (typeof action !== 'function') {\n      throw new Error(\n        `A \"use server\" file can only export async functions, found ${typeof action}.\\nRead more: https://nextjs.org/docs/messages/invalid-use-server-value`\n      )\n    }\n  }\n}\n","\"use server\"\n\nimport { auth } from \"@/auth\"\nimport { prisma } from \"@/lib/prisma\"\nimport { revalidatePath } from \"next/cache\"\nimport { z } from \"zod\"\nimport bcrypt from \"bcryptjs\"\n\nconst profileSchema = z.object({\n    name: z.string().min(2),\n    avatarUrl: z.string().url().optional().or(z.literal(\"\")),\n})\n\nconst passwordSchema = z.object({\n    currentPassword: z.string().min(1),\n    newPassword: z.string().min(6),\n    confirmPassword: z.string().min(6),\n}).refine((data) => data.newPassword === data.confirmPassword, {\n    message: \"Passwords do not match\",\n    path: [\"confirmPassword\"],\n})\n\nexport async function updateProfile(formData: FormData) {\n    const session = await auth()\n    if (!session?.user?.id) return { error: \"Unauthorized\" }\n\n    const rawData = {\n        name: formData.get(\"name\"),\n        // avatarUrl: formData.get(\"avatarUrl\"), // Not in form yet but good to have\n    }\n\n    const validated = profileSchema.safeParse({ ...rawData, avatarUrl: \"\" }) // Default empty for now\n\n    if (!validated.success) {\n        return { error: validated.error.flatten().fieldErrors }\n    }\n\n    try {\n        await prisma.user.update({\n            where: { id: session.user.id },\n            data: {\n                name: validated.data.name,\n            }\n        })\n        revalidatePath(\"/settings\")\n        return { success: \"Profile updated successfully\" }\n    } catch (error) {\n        return { error: \"Failed to update profile\" }\n    }\n}\n\nexport async function changePassword(formData: FormData) {\n    const session = await auth()\n    if (!session?.user?.id) return { error: \"Unauthorized\" }\n\n    const rawData = {\n        currentPassword: formData.get(\"currentPassword\"),\n        newPassword: formData.get(\"newPassword\"),\n        confirmPassword: formData.get(\"confirmPassword\"),\n    }\n\n    const validated = passwordSchema.safeParse(rawData)\n\n    if (!validated.success) {\n        return { error: validated.error.flatten().fieldErrors }\n    }\n\n    const { currentPassword, newPassword } = validated.data\n\n    const user = await prisma.user.findUnique({\n        where: { id: session.user.id }\n    })\n\n    if (!user || !user.password) {\n        return { error: \"User not found\" }\n    }\n\n    const passwordMatch = await bcrypt.compare(currentPassword, user.password)\n\n    if (!passwordMatch) {\n        return { error: \"Incorrect current password\" }\n    }\n\n    const hashedPassword = await bcrypt.hash(newPassword, 10)\n\n    try {\n        await prisma.user.update({\n            where: { id: session.user.id },\n            data: {\n                password: hashedPassword\n            }\n        })\n        return { success: \"Password changed successfully\" }\n    } catch (error) {\n        return { error: \"Failed to change password\" }\n    }\n}\n\nexport async function getTeamMembers() {\n    const session = await auth()\n    if (!session?.user?.id) return []\n\n    // Only allow managers/admins to see full list? or everyone?\n    // For now everyone can see the team.\n    return await prisma.user.findMany({\n        select: {\n            id: true,\n            name: true,\n            email: true,\n            role: true,\n            avatarUrl: true\n        },\n        orderBy: { name: 'asc' }\n    })\n}\n","export {$$RSC_SERVER_ACTION_0 as '001ceff8282c4239bec770d6cac094d371cf582016'} from 'ACTIONS_MODULE0'\nexport {updateProfile as '405ecb337e474ca485a267934222e68fc27a3be732'} from 'ACTIONS_MODULE1'\nexport {changePassword as '40de9e3b1508506c7fdf0853c7631da623a36d56ef'} from 'ACTIONS_MODULE1'\nexport {getTeamMembers as '00b1cfea4e5e65ecb8d20ccaab42f120649d3da462'} from 'ACTIONS_MODULE1'\nexport {updateProfile as '405ecb337e474ca485a267934222e68fc27a3be732'} from 'ACTIONS_MODULE1'\nexport {changePassword as '40de9e3b1508506c7fdf0853c7631da623a36d56ef'} from 'ACTIONS_MODULE1'\n"],"names":["ensureServerEntryExports","actions","i","length","action","Error"],"mappings":"6CAGO,SAASA,EAAyBC,CAAc,EACrD,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAQE,MAAM,CAAED,IAAK,CACvC,IAAME,EAASH,CAAO,CAACC,EAAE,CACzB,GAAsB,YAAlB,AAA8B,OAAvBE,EACT,MAAM,OAAA,cAEL,CAFK,AAAIC,MACR,CAAC,2DAA2D,EAAE,OAAOD,EAAO;AAAA,oEAAuE,CAAC,EADhJ,oBAAA,OAAA,mBAAA,eAAA,EAEN,EAEJ,CACF,0EATgBJ,2BAAAA,qCAAAA,8CCDhB,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA,oBAEA,IAAM,EAAgB,EAAA,CAAC,CAAC,MAAM,CAAC,CAC3B,KAAM,EAAA,CAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GACrB,UAAW,EAAA,CAAC,CAAC,MAAM,GAAG,GAAG,GAAG,QAAQ,GAAG,EAAE,CAAC,EAAA,CAAC,CAAC,OAAO,CAAC,IACxD,GAEM,EAAiB,EAAA,CAAC,CAAC,MAAM,CAAC,CAC5B,gBAAiB,EAAA,CAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAChC,YAAa,EAAA,CAAC,CAAC,MAAM,GAAG,GAAG,CAAC,GAC5B,gBAAiB,EAAA,CAAC,CAAC,MAAM,GAAG,GAAG,CAAC,EACpC,GAAG,MAAM,CAAC,AAAC,GAAS,EAAK,WAAW,GAAK,EAAK,eAAe,CAAE,CAC3D,QAAS,yBACT,KAAM,CAAC,kBAAkB,AAC7B,GAEO,eAAe,EAAc,CAAkB,EAClD,IAAM,EAAU,MAAM,CAAA,EAAA,EAAA,IAAA,AAAI,IAC1B,GAAI,CAAC,GAAS,MAAM,GAAI,MAAO,CAAE,MAAO,cAAe,EAEvD,IAAM,EAAU,CACZ,KAAM,EAAS,GAAG,CAAC,OAEvB,EAEM,EAAY,EAAc,SAAS,CAAC,CAAE,GAAG,CAAO,CAAE,UAAW,EAAG,GAAG,AAEzE,GAAI,CAAC,EAAU,OAAO,CAClB,CADoB,KACb,CAAE,GAHoF,GAG7E,EAAU,KAAK,CAAC,OAAO,GAAG,WAAW,AAAC,EAG1D,GAAI,CAQA,OAPA,MAAM,EAAA,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CACrB,MAAO,CAAE,GAAI,EAAQ,IAAI,CAAC,EAAE,AAAC,EAC7B,KAAM,CACF,KAAM,EAAU,IAAI,CAAC,IAAI,AAC7B,CACJ,GACA,CAAA,EAAA,EAAA,cAAA,AAAc,EAAC,aACR,CAAE,QAAS,8BAA+B,CACrD,CAAE,MAAO,EAAO,CACZ,MAAO,CAAE,MAAO,0BAA2B,CAC/C,CACJ,CAEO,eAAe,EAAe,CAAkB,EACnD,IAAM,EAAU,MAAM,CAAA,EAAA,EAAA,IAAA,AAAI,IAC1B,GAAI,CAAC,GAAS,MAAM,GAAI,MAAO,CAAE,MAAO,cAAe,EAEvD,IAAM,EAAU,CACZ,gBAAiB,EAAS,GAAG,CAAC,mBAC9B,YAAa,EAAS,GAAG,CAAC,eAC1B,gBAAiB,EAAS,GAAG,CAAC,kBAClC,EAEM,EAAY,EAAe,SAAS,CAAC,GAE3C,GAAI,CAAC,EAAU,OAAO,CAClB,CADoB,KACb,CAAE,MAAO,EAAU,KAAK,CAAC,OAAO,GAAG,WAAW,AAAC,EAG1D,GAAM,iBAAE,CAAe,aAAE,CAAW,CAAE,CAAG,EAAU,IAAI,CAEjD,EAAO,MAAM,EAAA,MAAM,CAAC,IAAI,CAAC,UAAU,CAAC,CACtC,MAAO,CAAE,GAAI,EAAQ,IAAI,CAAC,EAAE,AAAC,CACjC,GAEA,GAAI,CAAC,GAAQ,CAAC,EAAK,QAAQ,CACvB,CADyB,KAClB,CAAE,MAAO,gBAAiB,EAKrC,GAAI,CAFkB,AAEjB,MAFuB,EAAA,OAAM,AAEd,CAFe,OAAO,CAAC,EAAiB,EAAK,QAAQ,EAGrE,MAAO,CAAE,MAAO,4BAA6B,EAGjD,IAAM,EAAiB,MAAM,EAAA,OAAM,CAAC,IAAI,CAAC,EAAa,IAEtD,GAAI,CAOA,OANA,MAAM,EAAA,MAAM,CAAC,IAAI,CAAC,MAAM,CAAC,CACrB,MAAO,CAAE,GAAI,EAAQ,IAAI,CAAC,EAAE,AAAC,EAC7B,KAAM,CACF,SAAU,CACd,CACJ,GACO,CAAE,QAAS,+BAAgC,CACtD,CAAE,MAAO,EAAO,CACZ,MAAO,CAAE,MAAO,2BAA4B,CAChD,CACJ,CAEO,eAAe,IAClB,IAAM,EAAU,MAAM,CAAA,EAAA,EAAA,IAAA,AAAI,WAC1B,AAAK,GAAS,CAAV,KAAgB,GAIb,CAJiB,KAIX,EAAA,MAAM,CAAC,IAAI,CAAC,QAAQ,CAAC,CAC9B,OAAQ,CACJ,IAAI,EACJ,KAAM,GACN,MAAO,GACP,MAAM,EACN,WAAW,CACf,EACA,QAAS,CAAE,KAAM,KAAM,CAC3B,GAb+B,EAcnC,AAdqC,iCA9Ef,EA6BA,EA+CA,IA5EA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,MA6BA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,MA+CA,CAAA,EAAA,EAAA,uBAAA,EAAA,EAAA,6CAAA,yGClGtB,IAAA,EAAA,EAAA,CAAA,CAAA,OACA,EAAA,EAAA,CAAA,CAAA","ignoreList":[0]}